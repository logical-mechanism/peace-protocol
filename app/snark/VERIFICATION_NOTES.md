# Groth16 Verification Notes

## Issue Summary

Manual Groth16 pairing verification fails for proofs generated by gnark, even though gnark's built-in `groth16.Verify()` succeeds.

## Root Cause

There appears to be a subtle difference between gnark's internal verification implementation and the textbook Groth16 pairing equation:

```
e(A, B) = e(α, β) · e(vk_x, γ) · e(C, δ)
```

## Debugging Findings

1. **The proof IS valid** - gnark verifies it successfully during proof generation
2. **Manual pairing fails** - Both Go and Python manual implementations fail
3. **Public input mismatch**:
   - Circuit: 36 public inputs
   - Exported public.json: 37 inputs (with leading "1")
   - VK: 38 IC elements

## Attempts Made

Tried multiple verification strategies:
- `strict`: vk_x = IC[0] + Σ(inputs[i] * IC[i+1])
- `drop1_shiftIC`: Skip inputs[0]="1", use IC[2:]
- `gnark_internal_37IC`: Use first 37 IC elements with 36 inputs
- Alternative pairing equations with negated elements

All failed.

## Workaround

Use gnark's built-in verification via subprocess:

```python
from src.snark_verify_wrapper import verify_snark_proof_via_go

result = verify_snark_proof_via_go("out")
```

This calls the `snark verify` command which uses gnark's internal verification.

## Future Investigation

To fully understand this, would need to:
1. Compare gnark's Verify() implementation line-by-line with standard Groth16
2. Check if gnark uses a different curve encoding or pairing convention
3. Verify the Miller loop / final exponentiation implementations match
