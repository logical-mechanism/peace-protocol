/**
 * Payload CBOR encoding/decoding tests.
 *
 * These mirror tests verify that the TypeScript implementation produces
 * byte-identical CBOR output to Python's cbor2 with canonical=True.
 * The shared test vectors in test-vectors/payload-vectors.json are the
 * source of truth (generated by Python).
 */

import { describe, it, expect } from 'vitest';
import {
  buildPayload,
  parsePayload,
  buildPayloadHex,
  parsePayloadHex,
} from '../payload';
import { hexToBytes, bytesToHex } from '../bls12381';
import testVectors from '../../../../../../test-vectors/payload-vectors.json';

describe('payload CBOR encoding', () => {
  describe('buildPayload', () => {
    it('encodes locator-only payload', () => {
      const result = buildPayload({ locator: new Uint8Array([0xde, 0xad, 0xbe, 0xef]) });
      expect(bytesToHex(result)).toBe('a10044deadbeef');
    });

    it('encodes all three fields', () => {
      const result = buildPayload({
        locator: new Uint8Array([0xaa]),
        secret: new Uint8Array([0xbb]),
        digest: new Uint8Array([0xcc]),
      });
      const parsed = parsePayload(result);
      expect(parsed.get(0)).toEqual(new Uint8Array([0xaa]));
      expect(parsed.get(1)).toEqual(new Uint8Array([0xbb]));
      expect(parsed.get(2)).toEqual(new Uint8Array([0xcc]));
    });

    it('omits field 1 when secret is undefined', () => {
      const result = buildPayload({
        locator: new Uint8Array([0xaa]),
        digest: new Uint8Array([0xcc]),
      });
      const parsed = parsePayload(result);
      expect(parsed.has(0)).toBe(true);
      expect(parsed.has(1)).toBe(false);
      expect(parsed.has(2)).toBe(true);
    });

    it('encodes empty locator', () => {
      const result = buildPayload({ locator: new Uint8Array([]) });
      const parsed = parsePayload(result);
      expect(parsed.get(0)).toEqual(new Uint8Array([]));
    });

    it('encodes extra fields', () => {
      const extra = new Map<number, Uint8Array>();
      extra.set(3, new Uint8Array([0xdd]));
      extra.set(4, new Uint8Array([0xee]));
      const result = buildPayload({
        locator: new Uint8Array([0xaa]),
        extra,
      });
      const parsed = parsePayload(result);
      expect(parsed.get(3)).toEqual(new Uint8Array([0xdd]));
      expect(parsed.get(4)).toEqual(new Uint8Array([0xee]));
    });

    it('rejects extra key 0', () => {
      const extra = new Map<number, Uint8Array>();
      extra.set(0, new Uint8Array([0xff]));
      expect(() =>
        buildPayload({ locator: new Uint8Array([0xaa]), extra })
      ).toThrow('reserved');
    });

    it('rejects extra key 1', () => {
      const extra = new Map<number, Uint8Array>();
      extra.set(1, new Uint8Array([0xff]));
      expect(() =>
        buildPayload({ locator: new Uint8Array([0xaa]), extra })
      ).toThrow('reserved');
    });

    it('rejects extra key 2', () => {
      const extra = new Map<number, Uint8Array>();
      extra.set(2, new Uint8Array([0xff]));
      expect(() =>
        buildPayload({ locator: new Uint8Array([0xaa]), extra })
      ).toThrow('reserved');
    });

    it('produces deterministic output', () => {
      const a = buildPayload({
        locator: new Uint8Array([0xaa]),
        secret: new Uint8Array([0xbb]),
      });
      const b = buildPayload({
        locator: new Uint8Array([0xaa]),
        secret: new Uint8Array([0xbb]),
      });
      expect(bytesToHex(a)).toBe(bytesToHex(b));
    });
  });

  describe('parsePayload', () => {
    it('roundtrips locator-only', () => {
      const original = buildPayload({ locator: new Uint8Array([0xde, 0xad]) });
      const m = parsePayload(original);
      expect(m.get(0)).toEqual(new Uint8Array([0xde, 0xad]));
      expect(m.size).toBe(1);
    });

    it('roundtrips all three fields', () => {
      const original = buildPayload({
        locator: new Uint8Array([0xaa]),
        secret: new Uint8Array([0xbb]),
        digest: new Uint8Array([0xcc]),
      });
      const m = parsePayload(original);
      expect(m.get(0)).toEqual(new Uint8Array([0xaa]));
      expect(m.get(1)).toEqual(new Uint8Array([0xbb]));
      expect(m.get(2)).toEqual(new Uint8Array([0xcc]));
    });

    it('rejects missing locator', () => {
      // CBOR map {1: h'aa'} â€” no field 0
      const data = hexToBytes('a10141aa');
      expect(() => parsePayload(data)).toThrow('Missing required field 0');
    });
  });

  describe('hex convenience wrappers', () => {
    it('buildPayloadHex returns hex string', () => {
      const result = buildPayloadHex({ locator: 'deadbeef' });
      expect(result).toBe('a10044deadbeef');
    });

    it('parsePayloadHex returns hex fields', () => {
      const result = parsePayloadHex('a30044aabbccdd014411223344024455667788');
      expect(result.locator).toBe('aabbccdd');
      expect(result.secret).toBe('11223344');
      expect(result.digest).toBe('55667788');
    });

    it('parsePayloadHex handles missing optional fields', () => {
      const result = parsePayloadHex('a10044deadbeef');
      expect(result.locator).toBe('deadbeef');
      expect(result.secret).toBeUndefined();
      expect(result.digest).toBeUndefined();
    });
  });

  describe('cross-platform test vectors (mirror check)', () => {
    testVectors.forEach((vec) => {
      it(`matches Python output: ${vec.name}`, () => {
        const locator = hexToBytes(vec.fields['0']);
        const secret = vec.fields['1'] !== undefined ? hexToBytes(vec.fields['1']) : undefined;
        const digest = vec.fields['2'] !== undefined ? hexToBytes(vec.fields['2']) : undefined;

        let extra: Map<number, Uint8Array> | undefined;
        for (const [k, v] of Object.entries(vec.fields)) {
          const ki = parseInt(k, 10);
          if (ki >= 3) {
            if (!extra) extra = new Map();
            extra.set(ki, hexToBytes(v));
          }
        }

        const encoded = buildPayload({ locator, secret, digest, extra });
        expect(bytesToHex(encoded)).toBe(vec.cbor_hex);
      });
    });

    testVectors.forEach((vec) => {
      it(`roundtrips vector: ${vec.name}`, () => {
        const data = hexToBytes(vec.cbor_hex);
        const m = parsePayload(data);
        expect(m.has(0)).toBe(true);
        for (const [k, v] of Object.entries(vec.fields)) {
          const ki = parseInt(k, 10);
          expect(bytesToHex(m.get(ki)!)).toBe(v);
        }
      });
    });
  });
});
